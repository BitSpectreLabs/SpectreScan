"""
Markdown report generation for SpectreScan
by BitSpectreLabs

GitHub-flavored Markdown compatible report generator with
Mermaid diagram support, collapsible sections, and customizable templates.
"""

from typing import List, Dict, Optional, Any
from pathlib import Path
from datetime import datetime
from collections import Counter, defaultdict

from spectrescan.core.utils import ScanResult, HostInfo, get_timestamp


class MarkdownReportGenerator:
    """
    Generate professional Markdown reports from scan results.
    
    Features:
    - GitHub-flavored Markdown compatibility
    - Table of contents generation
    - Summary statistics section
    - Host/port tables
    - Service details with banners
    - Mermaid diagram support for network topology
    - Collapsible sections for large scans
    - Customizable templates
    """
    
    def __init__(
        self,
        include_toc: bool = True,
        include_mermaid: bool = True,
        include_banners: bool = True,
        collapsible_threshold: int = 20,
        template: Optional[str] = None
    ):
        """
        Initialize the Markdown report generator.
        
        Args:
            include_toc: Include table of contents
            include_mermaid: Include Mermaid network topology diagram
            include_banners: Include service banners in output
            collapsible_threshold: Number of results before using collapsible sections
            template: Optional custom template string
        """
        self.include_toc = include_toc
        self.include_mermaid = include_mermaid
        self.include_banners = include_banners
        self.collapsible_threshold = collapsible_threshold
        self.template = template
    
    def generate(
        self,
        results: List[ScanResult],
        output_path: Optional[Path] = None,
        summary: Optional[Dict[str, Any]] = None,
        host_info: Optional[Dict[str, HostInfo]] = None,
        title: Optional[str] = None
    ) -> str:
        """
        Generate a Markdown report.
        
        Args:
            results: List of scan results
            output_path: Optional path to save report
            summary: Optional scan summary dictionary
            host_info: Optional host information dictionary
            title: Optional custom report title
            
        Returns:
            Generated Markdown content as string
        """
        timestamp = get_timestamp()
        report_title = title or f"SpectreScan Report - {timestamp}"
        
        sections = []
        
        # Header
        sections.append(self._generate_header(report_title, timestamp))
        
        # Table of Contents
        if self.include_toc:
            sections.append(self._generate_toc(results, host_info))
        
        # Summary Statistics
        sections.append(self._generate_summary(results, summary))
        
        # Network Topology (Mermaid)
        if self.include_mermaid and results:
            sections.append(self._generate_mermaid_diagram(results, host_info))
        
        # Host Information
        if host_info:
            sections.append(self._generate_host_info(host_info))
        
        # Scan Results
        sections.append(self._generate_results_section(results))
        
        # Service Details
        if self.include_banners:
            sections.append(self._generate_service_details(results))
        
        # Footer
        sections.append(self._generate_footer(timestamp))
        
        # Combine sections
        content = "\n\n".join(filter(None, sections))
        
        # Save to file if path provided
        if output_path:
            output_path = Path(output_path)
            output_path.parent.mkdir(parents=True, exist_ok=True)
            with open(output_path, 'w', encoding='utf-8') as f:
                f.write(content)
        
        return content
    
    def _generate_header(self, title: str, timestamp: str) -> str:
        """Generate report header."""
        return f"""# {title}

> **Generated by:** SpectreScan  
> **Vendor:** BitSpectreLabs  
> **Report Date:** {timestamp}

---"""
    
    def _generate_toc(
        self,
        results: List[ScanResult],
        host_info: Optional[Dict[str, HostInfo]]
    ) -> str:
        """Generate table of contents."""
        toc_items = [
            "## Table of Contents",
            "",
            "- [Summary Statistics](#summary-statistics)"
        ]
        
        if self.include_mermaid and results:
            toc_items.append("- [Network Topology](#network-topology)")
        
        if host_info:
            toc_items.append("- [Host Information](#host-information)")
        
        toc_items.append("- [Scan Results](#scan-results)")
        
        if self.include_banners:
            toc_items.append("- [Service Details](#service-details)")
        
        return "\n".join(toc_items)
    
    def _generate_summary(
        self,
        results: List[ScanResult],
        summary: Optional[Dict[str, Any]]
    ) -> str:
        """Generate summary statistics section."""
        # Calculate statistics
        total_ports = len(results)
        open_ports = sum(1 for r in results if r.state == "open")
        closed_ports = sum(1 for r in results if r.state == "closed")
        filtered_ports = sum(1 for r in results if r.state == "filtered")
        
        # Unique hosts
        unique_hosts = set(r.host for r in results)
        
        # Services detected
        services = [r.service for r in results if r.service]
        service_count = len(set(services))
        
        # Build summary section
        lines = [
            "## Summary Statistics",
            "",
            "| Metric | Value |",
            "|--------|-------|",
            f"| Total Ports Scanned | {total_ports} |",
            f"| Open Ports | {open_ports} |",
            f"| Closed Ports | {closed_ports} |",
            f"| Filtered Ports | {filtered_ports} |",
            f"| Unique Hosts | {len(unique_hosts)} |",
            f"| Services Detected | {service_count} |"
        ]
        
        # Add custom summary fields if provided
        if summary:
            lines.append("")
            lines.append("### Additional Information")
            lines.append("")
            lines.append("| Field | Value |")
            lines.append("|-------|-------|")
            
            for key, value in summary.items():
                # Format datetime objects
                if hasattr(value, 'isoformat'):
                    value = value.isoformat()
                # Escape pipe characters in values
                value_str = str(value).replace("|", "\\|")
                key_formatted = key.replace("_", " ").title()
                lines.append(f"| {key_formatted} | {value_str} |")
        
        return "\n".join(lines)
    
    def _generate_mermaid_diagram(
        self,
        results: List[ScanResult],
        host_info: Optional[Dict[str, HostInfo]]
    ) -> str:
        """Generate Mermaid network topology diagram."""
        # Group results by host
        hosts_ports = defaultdict(list)
        for r in results:
            if r.state == "open":
                hosts_ports[r.host].append(r)
        
        if not hosts_ports:
            return ""
        
        lines = [
            "## Network Topology",
            "",
            "```mermaid",
            "graph TD",
            "    Scanner[SpectreScan Scanner]"
        ]
        
        # Add nodes for each host
        for idx, (host, ports) in enumerate(hosts_ports.items()):
            node_id = f"H{idx}"
            
            # Get host display name
            if host_info and host in host_info:
                display_name = host_info[host].hostname or host
            else:
                display_name = host
            
            # Create host node
            port_count = len(ports)
            lines.append(f"    {node_id}[{display_name}<br/>{port_count} open ports]")
            lines.append(f"    Scanner --> {node_id}")
            
            # Add service nodes for top services (limit to avoid cluttering)
            services = Counter(p.service for p in ports if p.service)
            top_services = services.most_common(5)
            
            for svc_idx, (service, count) in enumerate(top_services):
                svc_node_id = f"{node_id}S{svc_idx}"
                lines.append(f"    {svc_node_id}({service}: {count})")
                lines.append(f"    {node_id} --> {svc_node_id}")
        
        lines.append("```")
        
        return "\n".join(lines)
    
    def _generate_host_info(self, host_info: Dict[str, HostInfo]) -> str:
        """Generate host information section."""
        lines = [
            "## Host Information",
            "",
            "| IP Address | Hostname | OS | TTL | Latency |",
            "|------------|----------|----|----|---------|"
        ]
        
        for ip, info in host_info.items():
            hostname = info.hostname or "-"
            os_guess = info.os_guess or "-"
            ttl = str(info.ttl) if info.ttl else "-"
            latency = f"{info.latency_ms:.2f}ms" if info.latency_ms else "-"
            
            lines.append(f"| {ip} | {hostname} | {os_guess} | {ttl} | {latency} |")
        
        return "\n".join(lines)
    
    def _generate_results_section(self, results: List[ScanResult]) -> str:
        """Generate scan results section with tables."""
        lines = ["## Scan Results"]
        
        # Group results by host
        hosts_results = defaultdict(list)
        for r in results:
            hosts_results[r.host].append(r)
        
        # Check if we need collapsible sections
        use_collapsible = len(results) > self.collapsible_threshold
        
        for host, host_results in hosts_results.items():
            # Sort by port number
            host_results.sort(key=lambda x: x.port)
            
            # Open ports for this host
            open_count = sum(1 for r in host_results if r.state == "open")
            
            if use_collapsible:
                lines.append("")
                lines.append(f"<details>")
                lines.append(f"<summary><strong>{host}</strong> - {len(host_results)} ports ({open_count} open)</summary>")
                lines.append("")
            else:
                lines.append("")
                lines.append(f"### {host}")
                lines.append("")
            
            # Create table
            lines.append("| Port | Protocol | State | Service |")
            lines.append("|------|----------|-------|---------|")
            
            for r in host_results:
                state_badge = self._get_state_badge(r.state)
                service = r.service or "-"
                lines.append(f"| {r.port} | {r.protocol} | {state_badge} | {service} |")
            
            if use_collapsible:
                lines.append("")
                lines.append("</details>")
        
        return "\n".join(lines)
    
    def _get_state_badge(self, state: str) -> str:
        """Get a badge/emoji for port state."""
        badges = {
            "open": "**OPEN**",
            "closed": "CLOSED",
            "filtered": "*filtered*",
            "open|filtered": "*open|filtered*"
        }
        return badges.get(state.lower(), state)
    
    def _generate_service_details(self, results: List[ScanResult]) -> str:
        """Generate service details section with banners."""
        # Filter results with banners
        results_with_banners = [r for r in results if r.banner]
        
        if not results_with_banners:
            return ""
        
        lines = [
            "## Service Details",
            "",
            "Detailed service information and banners captured during the scan."
        ]
        
        # Check if we need collapsible sections
        use_collapsible = len(results_with_banners) > self.collapsible_threshold
        
        for r in results_with_banners:
            service_name = r.service or "Unknown Service"
            
            if use_collapsible:
                lines.append("")
                lines.append(f"<details>")
                lines.append(f"<summary><code>{r.host}:{r.port}</code> - {service_name}</summary>")
                lines.append("")
            else:
                lines.append("")
                lines.append(f"### {r.host}:{r.port} - {service_name}")
                lines.append("")
            
            lines.append(f"- **Host:** {r.host}")
            lines.append(f"- **Port:** {r.port}/{r.protocol}")
            lines.append(f"- **State:** {r.state}")
            lines.append(f"- **Service:** {service_name}")
            lines.append("")
            lines.append("**Banner:**")
            lines.append("")
            lines.append("```")
            # Escape code block markers in banner
            banner_text = r.banner.replace("```", "` ` `")
            lines.append(banner_text)
            lines.append("```")
            
            if use_collapsible:
                lines.append("")
                lines.append("</details>")
        
        return "\n".join(lines)
    
    def _generate_footer(self, timestamp: str) -> str:
        """Generate report footer."""
        return f"""---

## About This Report

This report was generated by **SpectreScan**, a professional-grade port scanning toolkit developed by **BitSpectreLabs**.

- **Documentation:** [GitHub Repository](https://github.com/BitSpectreLabs/SpectreScan)
- **Report Format:** GitHub-Flavored Markdown (GFM)
- **Generated:** {timestamp}

---

*SpectreScan - Professional Port Scanner by BitSpectreLabs*"""


def generate_markdown_report(
    results: List[ScanResult],
    output_path: Path,
    summary: Optional[Dict[str, Any]] = None,
    host_info: Optional[Dict[str, HostInfo]] = None,
    include_toc: bool = True,
    include_mermaid: bool = True,
    include_banners: bool = True,
    collapsible_threshold: int = 20,
    title: Optional[str] = None
) -> str:
    """
    Generate a Markdown report (convenience function).
    
    Args:
        results: List of scan results
        output_path: Path to save report
        summary: Optional scan summary dictionary
        host_info: Optional host information dictionary
        include_toc: Include table of contents
        include_mermaid: Include Mermaid network topology diagram
        include_banners: Include service banners
        collapsible_threshold: Number of results before using collapsible sections
        title: Optional custom report title
        
    Returns:
        Generated Markdown content as string
    """
    generator = MarkdownReportGenerator(
        include_toc=include_toc,
        include_mermaid=include_mermaid,
        include_banners=include_banners,
        collapsible_threshold=collapsible_threshold
    )
    
    return generator.generate(
        results=results,
        output_path=output_path,
        summary=summary,
        host_info=host_info,
        title=title
    )


def generate_simple_markdown(
    results: List[ScanResult],
    output_path: Optional[Path] = None
) -> str:
    """
    Generate a simple Markdown report (minimal formatting).
    
    Args:
        results: List of scan results
        output_path: Optional path to save report
        
    Returns:
        Generated Markdown content
    """
    lines = [
        "# SpectreScan Report",
        "",
        f"> Generated: {get_timestamp()}",
        "",
        "## Results",
        "",
        "| Host | Port | Protocol | State | Service |",
        "|------|------|----------|-------|---------|"
    ]
    
    for r in results:
        service = r.service or "-"
        lines.append(f"| {r.host} | {r.port} | {r.protocol} | {r.state} | {service} |")
    
    content = "\n".join(lines)
    
    if output_path:
        output_path = Path(output_path)
        output_path.parent.mkdir(parents=True, exist_ok=True)
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(content)
    
    return content


def generate_markdown_summary(
    results: List[ScanResult],
    summary: Optional[Dict[str, Any]] = None
) -> str:
    """
    Generate a brief Markdown summary (no file output).
    
    Args:
        results: List of scan results
        summary: Optional scan summary dictionary
        
    Returns:
        Markdown summary string
    """
    total = len(results)
    open_count = sum(1 for r in results if r.state == "open")
    closed_count = sum(1 for r in results if r.state == "closed")
    filtered_count = sum(1 for r in results if r.state == "filtered")
    hosts = len(set(r.host for r in results))
    
    lines = [
        "## Scan Summary",
        "",
        f"- **Total Ports:** {total}",
        f"- **Open:** {open_count}",
        f"- **Closed:** {closed_count}",
        f"- **Filtered:** {filtered_count}",
        f"- **Hosts Scanned:** {hosts}"
    ]
    
    if summary:
        lines.append("")
        for key, value in summary.items():
            if hasattr(value, 'isoformat'):
                value = value.isoformat()
            key_formatted = key.replace("_", " ").title()
            lines.append(f"- **{key_formatted}:** {value}")
    
    return "\n".join(lines)


def results_to_markdown_table(
    results: List[ScanResult],
    include_banner: bool = False
) -> str:
    """
    Convert scan results to a Markdown table.
    
    Args:
        results: List of scan results
        include_banner: Include banner column
        
    Returns:
        Markdown table string
    """
    if include_banner:
        lines = [
            "| Host | Port | Protocol | State | Service | Banner |",
            "|------|------|----------|-------|---------|--------|"
        ]
        
        for r in results:
            service = r.service or "-"
            banner = (r.banner or "-").replace("|", "\\|").replace("\n", " ")[:50]
            if r.banner and len(r.banner) > 50:
                banner += "..."
            lines.append(f"| {r.host} | {r.port} | {r.protocol} | {r.state} | {service} | {banner} |")
    else:
        lines = [
            "| Host | Port | Protocol | State | Service |",
            "|------|------|----------|-------|---------|"
        ]
        
        for r in results:
            service = r.service or "-"
            lines.append(f"| {r.host} | {r.port} | {r.protocol} | {r.state} | {service} |")
    
    return "\n".join(lines)


# Template presets for different use cases
TEMPLATE_MINIMAL = """# {title}

{results_table}

---
*Generated by SpectreScan*
"""

TEMPLATE_EXECUTIVE = """# {title}

## Executive Summary

{summary}

## Key Findings

{findings}

## Recommendations

{recommendations}

---
*SpectreScan - BitSpectreLabs*
"""

TEMPLATE_TECHNICAL = """# {title}

## Scan Configuration

{config}

## Results Summary

{summary}

## Detailed Results

{results}

## Service Banners

{banners}

## Network Topology

{topology}

---
*SpectreScan Technical Report*
"""


__all__ = [
    "MarkdownReportGenerator",
    "generate_markdown_report",
    "generate_simple_markdown",
    "generate_markdown_summary",
    "results_to_markdown_table",
    "TEMPLATE_MINIMAL",
    "TEMPLATE_EXECUTIVE",
    "TEMPLATE_TECHNICAL"
]
